"""
Triangle, pentagonal, and hexagonal numbers are generated by the
following formulae:

Triangle	 	Tn=n(n+1)/2	 	1, 3, 6, 10, 15, ...
Pentagonal	 	Pn=n(3n−1)/2	 	1, 5, 12, 22, 35, ...
Hexagonal	 	Hn=n(2n−1)	 	1, 6, 15, 28, 45, ...
It can be verified that T285 = P165 = H143 = 40755.

Find the next triangle number that is also pentagonal and hexagonal.
"""

module problem045
export solve

"""
implement a binary search to test if a candidate T_i has a
matching F_j, where F is either P or H, and given by `func`.
`index` contains the current bounds of the search.

For the current iteration, `j` is computed as
    j = floor(diff(index)/2) + 1
and
    F_j = func(j)

the recursion is then implemented by
    F_j > T_i
        index[1] -= j
    F_j < T_i
        index[0] += j
    F_j == T_i
        return true

    binsearch(func, index)
"""
function binsearch(func, mm, T_i)
    while true
        diff(mm)[1] == 1 && return -1
        j = midpoint(mm)
        V = func(j)

        if V < T_i
            mm = [j, mm[2]]
        elseif V > T_i
            mm = [mm[1], j]
        else
            return j
        end
        #= println("V ", V, " j ", j, " mm ", mm, " T_i ", T_i) =#
    end
end

function midpoint(minmax)
    return round(Integer, floor(diff(minmax)/2) + minmax[1])[1]
end


function solve()
    T(n) = round(Int64, 1/2*n^2 + n/2)
    P(n) = round(Int64, 3/2*n^2 - n/2)
    H(n) = round(Int64, 2*n^2 - n)
    i0 = 285 + 1

    is_P_match(n) = binsearch(P, [1, n], T(n)) > 0
    is_H_match(n) = binsearch(H, [1, n], T(n)) > 0

    while !is_P_match(i0) || !is_H_match(i0)
        i0 += 1
    end
    j0 = binsearch(P, [1, i0], T(i0))
    k0 = binsearch(H, [1, i0], T(i0))
    println("i0 ", j0, " T(i0) ", T(i0), " P(j0) ", P(j0), " H(k0) ", H(k0))
end
end
